{"meta":{"title":"Gorilla_L","subtitle":"Gorilla_L的个人博客","description":"学习总结、累积知识、记录生活","author":"licanming","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Android插件化框架DroidPlugin-学习笔记（一）：简单介绍及集成使用","slug":"Android插件化框架DroidPlugin-学习笔记（一）：简单介绍及集成使用","date":"2019-01-25T07:24:02.000Z","updated":"2019-01-25T07:24:02.000Z","comments":true,"path":"2019/01/25/Android插件化框架DroidPlugin-学习笔记（一）：简单介绍及集成使用/","link":"","permalink":"http://yoursite.com/2019/01/25/Android插件化框架DroidPlugin-学习笔记（一）：简单介绍及集成使用/","excerpt":"","text":"PS：本文为本人学习的一个过程，大神可直接忽略，若发现有错误之处，请评论留言，小编会及时更正，不喜勿喷，谢谢。 最近公司叫预研一下插件化相关的技术，发现现在开源社区上，关于插件化这个技术的框架也不多，Android插件化主流的实现方案主要就是这两个框架，一个是dynamic-load-apk（简称DL），另一个则是奇虎360手机助手团队的DroidPlugin，这两个框架各有各的优缺点，下面就简单介绍一下两者的优缺点。 #####DynamicLoadApk是由团队维护的，但是目前已经很长时间没有更新了，途牛用的就是这个插件化框架 ######优点： 插件不依赖宿主，对宿主开发者透明，提供三种依赖方式 宿主和插件可以频繁交互，启动时间短######缺点： 插件apk必须实现DLBasePluginActivity，属于侵入式的，以及不支持service 宿主调用插件和插件内部的相互调用都要使用DL提供的方法，而不能使用Android原生的api，例如：启动Activity 插件开发有一套规定，因此造成插件开发门槛高，学习成本高#####DroidPlugin是360公司开源的一个框架，已经在360手机助手上使用######优点： 宿主和插件完全隔离，插件不依赖宿主，可以独立安装运行 低入侵设计，插件不需要继承任何类 插件apk和普通apk一样的，所以插件开发没有门槛 开发的时候集成简单，只需要三两个步骤即可集成到一个新的项目中 有大公司维护,有360手机助手这样的商用app在使用######缺点： 插件启动速度比较慢 无法在插件中发送具有自定义资源的Notification，例如： a. 带自定义RemoteLayout的Notification b. 图标通过R.drawable.XXX指定的通知（插件系统会自动将其转化为Bitmap） 无法在插件中注册一些具有特殊Intent Filter的Service、Activity、BroadcastReceiver、ContentProvider等组件以供Android系统、已经安装的其他APP调用。 缺乏对Native层的Hook，对某些带native代码的apk支持不好，可能无法运行。比如一部分游戏无法当作插件运行。 ######附上两个框架的GitHub地址 DynamicLoadApk的Github地址:https://github.com/singwhatiwanna/dynamic-load-apk DroidPlugin的Github地址:https://github.com/Qihoo360/DroidPlugin 在本文中主要简单地介绍一下DroidPlugin框架，DynamicLoadApk框架以后有时间再简单介绍。 ###1. DroidPlugin简介Android大型项目中为了减小apk的体积，可以采用插件化的方法，即一些不常用的功能独立成插件，当用户需要使用的时候再从服务器上下载回来，动态加载。这样就避免了为了满足所有用户需求而把功能全部打包到apk，导致apk体积的膨胀。所谓的插件，其实也是一个apk，但是一般都依赖正式对外发布的app，也叫宿主。 #####1.1 说明下面引入一下官方说明： DroidPlugin是360手机助手在Android系统上实现了一种新的插件机制:它可以在无需安装、修改的情况下运行APK文件,此机制对改进大型APP的架构，实现多团队协作开发具有一定的好处。 #####1.2 特点 支持Androd 2.3以上系统 插件APK完全不需做任何修改，可以独立安装运行、也可以做插件运行。要以插件模式运行某个APK，你无需重新编译、无需知道其源码。 插件的四大组件完全不需要在Host程序中注册，支持Service、Activity、BroadcastReceiver、ContentProvider四大组件 插件之间、Host程序与插件之间会互相认为对方已经”安装”在系统上了。 API低侵入性：极少的API。HOST程序只是需要一行代码即可集成Droid Plugin 超强隔离：插件之间、插件与Host之间完全的代码级别的隔离：不能互相调用对方的代码。通讯只能使用Android系统级别的通讯方法。 支持所有系统API 资源完全隔离：插件之间、与Host之间实现了资源完全隔离，不会出现资源窜用的情况。 实现了进程管理，插件的空进程会被及时回收，占用内存低。 插件的静态广播会被当作动态处理，如果插件没有运行（即没有插件进程运行），其静态广播也永远不回被触发。 ###2. 使用方法 #####2.1 集成在项目中集成DroidPlugin项目非常简单，只需以下几步即可： 我们只需要将Droid Plugin当作一个lib工程应用到主项目中。 在AndroidManifest.xml中使用插件的com.morgoo.droidplugin.PluginApplication： &lt;application android:name=&quot;com.morgoo.droidplugin.PluginApplication&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot; 如果你使用自定义的Application，那么你需要在自定义的Application class onCreate和attachBaseContext方法中添加如下代码： @Override public void onCreate() { super.onCreate(); //这里必须在super.onCreate方法之后，顺序不能变 PluginHelper.getInstance().applicationOnCreate(getBaseContext()); } @Override protected void attachBaseContext(Context base) { PluginHelper.getInstance().applicationAttachBaseContext(base); super.attachBaseContext(base); } PS: 其实DroidPlugin的PluginApplication里面也是添加了同样的代码。 public class PluginApplication extends Application { private static final String TAG = PluginApplication.class.getSimpleName(); @Override public void onCreate() { super.onCreate(); PluginHelper.getInstance().applicationOnCreate(getBaseContext()); } @Override protected void attachBaseContext(Context base) { PluginHelper.getInstance().applicationAttachBaseContext(base); super.attachBaseContext(base); } } 将插件中Libraries\\DroidPlugin\\AndroidManifest.xml中所有的provider对应的authorities修改成自己的，默认为com.morgoo.droidplugin_stub_P00，如下： &lt;provider android:name=&quot;com.morgoo.droidplugin.stub.ContentProviderStub$StubP00&quot; android:authorities=&quot;com.morgoo.droidplugin_stub_P00&quot; android:exported=&quot;false&quot; android:label=&quot;@string/stub_name_povider&quot; /&gt; 可以修改为自己的包名，如: com.example.droidplugindemo 防止跟其它本插件使用者冲突： &lt;provider android:name=&quot;com.morgoo.droidplugin.stub.ContentProviderStub$StubP00&quot; android:authorities=&quot;com.example.droidplugindemo_stub_P00&quot; android:exported=&quot;false&quot; android:label=&quot;@string/stub_name_povider&quot; /&gt; 注意:只修改前面的com.morgoo.droidplugin部分，后面的P00,P01…..不要改。如果不改authorities的话，会和360手机助手发生冲突，手机上装了360手机助手，再装这个就装不上去了 并且修改PluginManager.STUB_AUTHORITY_NAME 为你的值: PluginManager.STUB_AUTHORITY_NAME=&quot;com.example.droidplugindemo&quot; 到此，集成就大功告成。 #####2.2 安装、卸载插件 安装、更新插件,使用如下方法： int PluginManager.getInstance().installPackage(String filepath, int flags) 说明：安装插件到插件系统中，filepath为插件apk路径，flags可以设置为0，如果要更新插件，则设置为PackageManagerCompat.INSTALL_REPLACE_EXISTING返回值及其含义请参见PackageManagerCompat类中的相关字段。 /** * 以下每个常亮的注释是小编根据常亮命名来猜的，不代表官方说明，小编暂未找到官方解释。 */ public class PackageManagerCompat { public static final int DELETE_FAILED_INTERNAL_ERROR = -1;// 删除失败，内部错误 public static final int DELETE_SUCCEEDED = 1;// 删除成功 public static final int INSTALL_SUCCEEDED = 1;// 安装成功 public static final int INSTALL_FAILED_INTERNAL_ERROR = -110;// 安装失败，内部错误 public static final int INSTALL_FAILED_INVALID_APK = -2;// 安装失败，无效的apk public static final int INSTALL_REPLACE_EXISTING = 0x00000002;// 安装替换现有的 public static final int INSTALL_FAILED_ALREADY_EXISTS = -1;// 安装失败，已经存在 } 卸载插件，使用如下方法： int PluginManager.getInstance().deletePackage(String packageName,int flags); 说明：从插件系统中卸载某个插件，packageName传插件包名即可，flags传0。 启动插件：启动插件的Activity、Service等都和你启动一个以及安装在系统中的app一样，使用系统提供的相关API即可。组件间通讯也是如此。 ###3. 基本架构一个宿主App（Host程序），其他apk（Plugin App 1，Plugin App 2，…..）以插件的形式被宿主App加载，插件无需安装。 ###4. 插件Host程序架构 ###5. 实现原理本文只根据官方PPT介绍该框架的基本原理，具体的实现原理，请读者自行下载源码来分析以及查阅相关资料去了解，本文不对实现原理进行深入研究。 ###6. 基本原理 #####6.1 共享进程 #####6.2 Hook(API欺骗)之动态代理 #####6.3 Hook(API欺骗)之Binder代理 #####6.4 Hook(API欺骗)之Instrumentation代理 ###7. 解决四大组件注册问题 #####7.1 占坑 ###8. 自己实现包管理服务 ###9. 适配 #####小结DroidPlugin是奇虎360手机助手团队的产物，而且在360手机助手也应用上了，所以他们团队应该也还会维护，在Android插件化领域，DroidPlugin是目前实现的比较好的插件化框架，插件apk完全与宿主隔离而且不受侵入，优点也很明显，而且这个框架集成也比较简单，坑多不多，这个就要读者自己去踩踩了，但是目前小编还没踩到什么大坑。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"AndroidStudio 找不到cache.properties (系统找不到指定的文件。)","slug":"AndroidStudio-找不到cache-properties-系统找不到指定的文件。","date":"2019-01-25T07:19:03.000Z","updated":"2019-01-25T07:19:03.000Z","comments":true,"path":"2019/01/25/AndroidStudio-找不到cache-properties-系统找不到指定的文件。/","link":"","permalink":"http://yoursite.com/2019/01/25/AndroidStudio-找不到cache-properties-系统找不到指定的文件。/","excerpt":"","text":"今天在码代码的时候，该死的window崩溃了，导致死机了，强制关机重新启动之后，重新打开AndroidStudio的一个项目，报了下面这个错： Error:C:\\Users\\Gorilla_L.gradle\\caches\\3.3\\scripts-remapped\\build_1zzicyplhal3mtv4fug6pgh1s\\1krzami3nzk79kaphiupfmmr0\\cp_proj1efd45104ffa2d33563b85b9edda76e3\\cache.properties (系统找不到指定的文件。) 在网上看了好几篇文章，都说从AndroidStudio下拉菜单中执行以下步骤：File &gt; Invalidate Caches/Restart... 然后重新启动以重新创建缓存Build &gt; Clean Project我试过这个方法，不行。 后来又看到有些说删除.gradle文件夹，也有说删除caches文件夹的，但是我看了一下，这两个文件夹都好大，而且如果删除.gradle文件夹的话，你要运行之前的一些其他gradle版本的项目的时候，又要重新下载对应版本的gradle（或者更改项目的gradle.properties文件的对应gradle版本号），而且你不翻墙的话，AndroidStudio还不能自动下载gradle，还要自己手动去网上下载之后放到.gradle文件夹的相应目录中，可谓相当麻烦，所以我也没试这两个方法，但是这两个方法应该是可行的，因为我的解决方案也是相同道理。 废话了这么多，下面说说我的解决方法： 原理：我也是通过删除文件夹，然后重启AndroidStudio，让它重新生成相对应的文件即可。实现：删除C:\\Users\\user.gradle\\caches\\目录下的对应版本的文件夹，例如我的是：C:\\Users\\Gorilla_L.gradle\\caches\\3.3，我就删除3.3这个文件夹，然后重启AndroidStudio，打开报错的项目即可通过编译。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-25T06:47:44.318Z","updated":"2019-01-25T06:47:44.319Z","comments":true,"path":"2019/01/25/hello-world/","link":"","permalink":"http://yoursite.com/2019/01/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}